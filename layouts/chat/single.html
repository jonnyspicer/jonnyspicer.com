{{ define "main" }}
<div class="post post-chat">
    <div class="chat-interface">
        <div id="sidebar">
            <div class="sidebar-header">
                <h2>Personas</h2>
                <button id="info-button" class="info-button" aria-label="Information about personas">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M11.25 11.25l.041-.02a.75.75 0 011.063.852l-.708 2.836a.75.75 0 001.063.853l.041-.021M21 12a9 9 0 11-18 0 9 9 0 0118 0zm-9-3.75h.008v.008H12V8.25z" />
                    </svg>
                </button>
            </div>
            <div id="info-popup" class="info-popup hidden">
                <div class="info-content">
                    <h3>About the Chat Interface</h3>
                    <p>This chat interface allows you to interact with different AI personas:</p>
                    <ul>
                        <li><strong>Friendly Bot:</strong> A helpful and cheerful assistant</li>
                        <li><strong>Sarcastic Bot:</strong> Responds with wit and sarcasm</li>
                        <li><strong>Wise Bot:</strong> Provides thoughtful and insightful responses</li>
                        <li><strong>Coworker:</strong> A technical mentor and virtual cofounder</li>
                        <li><strong>Wedding Planner:</strong> Expert in UK wedding and proposal planning</li>
                        <li><strong>Programming Tutor:</strong> Experienced CS professor and systems programmer</li>
                        <li><strong>Therapist:</strong> IFS-trained therapeutic assistant</li>
                        <li><strong>User Researcher:</strong> Expert in product research and user insights</li>
                        <li><strong>Entrepreneur:</strong> Tech founder and strategic advisor</li>
                        <li><strong>Property Guide:</strong> Expert in London property buying</li>
                        <li><strong>Spiritual Teacher:</strong> Buddhist and Daoist wisdom guide</li>
                        <li><strong>Courtney:</strong> Jonny's partner</li>
                        <li><strong>Jonny:</strong> Creator of this chat interface</li>
                        <li><strong>Gabriel:</strong> Angelic advisor representing light, truth and harmony</li>
                        <li><strong>Mephistopheles:</strong> Devilish interlocutor representing temptation and critique</li>
                    </ul>
                    <h3>Group Chats</h3>
                    <p>You can also chat with groups of personas who will respond together:</p>
                    <ul>
                        <li><strong>Tech Team:</strong> A collaborative group with Coworker, Programming Tutor, and Entrepreneur</li>
                        <li><strong>Therapy Group:</strong> A supportive group with Therapist and Spiritual Teacher</li>
                        <li><strong>The Council:</strong> A diverse advisory panel with Coworker, Therapist, Entrepreneur, Spiritual Teacher, Gabriel, and Mephistopheles</li>
                    </ul>
                    <p>Your conversation history is saved in your browser's local storage.</p>
                    <p>Click on any persona to start chatting with it!</p>
                </div>
            </div>
            <div id="persona-list"></div>
        </div>
        <div id="chat-container">
            <div id="chat-header">
                <h2 id="chat-title">Friendly Bot</h2>
                <div class="header-controls">
                    <button id="members-button" class="members-button hidden" aria-label="View group members">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M15 19.128a9.38 9.38 0 002.625.372 9.337 9.337 0 004.121-.952 4.125 4.125 0 00-7.533-2.493M15 19.128v-.003c0-1.113-.285-2.16-.786-3.07M15 19.128v.106A12.318 12.318 0 018.624 21c-2.331 0-4.512-.645-6.374-1.766l-.001-.109a6.375 6.375 0 0111.964-3.07M12 6.375a3.375 3.375 0 11-6.75 0 3.375 3.375 0 016.75 0zm8.25 2.25a2.625 2.625 0 11-5.25 0 2.625 2.625 0 015.25 0z" />
                        </svg>
                    </button>
                    <button id="settings-button" class="settings-button" aria-label="Chat settings">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M9.594 3.94c.09-.542.56-.94 1.11-.94h2.593c.55 0 1.02.398 1.11.94l.213 1.281c.063.374.313.686.645.87.074.04.147.083.22.127.324.196.72.257 1.075.124l1.217-.456a1.125 1.125 0 011.37.49l1.296 2.247a1.125 1.125 0 01-.26 1.431l-1.003.827c-.293.24-.438.613-.431.992a6.759 6.759 0 010 .255c-.007.378.138.75.43.99l1.005.828c.424.35.534.954.26 1.43l-1.298 2.247a1.125 1.125 0 01-1.369.491l-1.217-.456c-.355-.133-.75-.072-1.076.124a6.57 6.57 0 01-.22.128c-.331.183-.581.495-.644.869l-.213 1.28c-.09.543-.56.941-1.11.941h-2.594c-.55 0-1.02-.398-1.11-.94l-.213-1.281c-.062-.374-.312-.686-.644-.87a6.52 6.52 0 01-.22-.127c-.325-.196-.72-.257-1.076-.124l-1.217.456a1.125 1.125 0 01-1.369-.49l-1.297-2.247a1.125 1.125 0 01.26-1.431l1.004-.827c.292-.24.437-.613.43-.992a6.932 6.932 0 010-.255c.007-.378-.138-.75-.43-.99l-1.004-.828a1.125 1.125 0 01-.26-1.43l1.297-2.247a1.125 1.125 0 011.37-.491l1.216.456c.356.133.751.072 1.076-.124.072-.044.146-.087.22-.128.332-.183.582-.495.644-.869l.214-1.281z" />
                            <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                        </svg>
                    </button>
                </div>
            </div>
            <div id="members-popup" class="members-popup hidden">
                <div class="members-content">
                    <h3>Group Members</h3>
                    <ul id="member-list"></ul>
                </div>
            </div>
            <div id="settings-popup" class="settings-popup hidden">
                <div class="settings-content">
                    <h3>Chat Settings</h3>
                    <button id="clear-chat-button" class="settings-button">Clear Current Chat</button>
                    <button id="clear-all-button" class="settings-button">Clear All Chats</button>
                </div>
            </div>
            <div id="chat-history"></div>
            <div id="input-container">
                <textarea id="message-input" placeholder="Type a message..." rows="1"></textarea>
                <button id="send-button">Send</button>
            </div>
        </div>
    </div>
</div>

<style>
.typing-indicator {
    display: inline-flex;
    min-height: 20px;
    opacity: 0.8;
    padding: 0;
    margin: 0;
}

.typing-indicator .dot {
    animation: dotBounce 1.4s infinite ease-in-out;
    margin: 0 -3px; /* Negative margin to bring dots closer together */
    letter-spacing: -3px; /* Reduce letter spacing */
}

/* Reduce padding in message bubbles that contain typing indicators */
.message.typing {
    padding: 4px;
}

.typing-indicator .dot:nth-child(1) {
    animation-delay: 0s;
}

.typing-indicator .dot:nth-child(2) {
    animation-delay: 0.2s;
}

.typing-indicator .dot:nth-child(3) {
    animation-delay: 0.4s;
}

@keyframes dotBounce {
    0%, 80%, 100% { transform: translateY(0); }
    40% { transform: translateY(-1px); }
}
</style>

{{ $promptsjs := resources.Get "js/prompts.js" }}

<script type="module">
    import { SYSTEM_PROMPTS } from '{{ $promptsjs.Permalink }}'
    
    // Define the available personas with their own conversation history.
    const personas = [
        {
            id: 1, 
            name: "Friendly Bot", 
            systemPrompt: SYSTEM_PROMPTS.FRIENDLY,
            promptKey: 'FRIENDLY',
            history: []
        },
        {
            id: 2, 
            name: "Sarcastic Bot", 
            systemPrompt: SYSTEM_PROMPTS.SARCASTIC,
            promptKey: 'SARCASTIC',
            history: []
        },
        {
            id: 3, 
            name: "Wise Bot", 
            systemPrompt: SYSTEM_PROMPTS.WISE,
            promptKey: 'WISE',
            history: []
        },
        {
            id: 4,
            name: "Coworker",
            systemPrompt: SYSTEM_PROMPTS.COWORKER,
            promptKey: 'COWORKER',
            history: []
        },
        {
            id: 5,
            name: "Wedding Planner",
            systemPrompt: SYSTEM_PROMPTS.WEDDING_PLANNER,
            promptKey: 'WEDDING_PLANNER',
            history: []
        },
        {
            id: 6,
            name: "Programming Tutor",
            systemPrompt: SYSTEM_PROMPTS.PROGRAMMING_TUTOR,
            promptKey: 'PROGRAMMING_TUTOR',
            history: []
        },
        {
            id: 7,
            name: "Therapist",
            systemPrompt: SYSTEM_PROMPTS.THERAPIST,
            promptKey: 'THERAPIST',
            history: []
        },
        {
            id: 8,
            name: "User Researcher",
            systemPrompt: SYSTEM_PROMPTS.USER_RESEARCHER,
            promptKey: 'USER_RESEARCHER',
            history: []
        },
        {
            id: 9,
            name: "Entrepreneur",
            systemPrompt: SYSTEM_PROMPTS.ENTREPRENEUR,
            promptKey: 'ENTREPRENEUR',
            history: []
        },
        {
            id: 10,
            name: "Property Guide",
            systemPrompt: SYSTEM_PROMPTS.PROPERTY_GUIDE,
            promptKey: 'PROPERTY_GUIDE',
            history: []
        },
        {
            id: 11,
            name: "Spiritual Teacher",
            systemPrompt: SYSTEM_PROMPTS.SPIRITUAL_TEACHER,
            promptKey: 'SPIRITUAL_TEACHER',
            history: []
        },
        {
            id: 12,
            name: "Courtney",
            systemPrompt: SYSTEM_PROMPTS.COURTNEY,
            promptKey: 'COURTNEY',
            history: []
        },
        {
            id: 13,
            name: "Jonny",
            systemPrompt: SYSTEM_PROMPTS.JONNY,
            promptKey: 'JONNY',
            history: []
        },
        {
            id: 14,
            name: "Gabriel",
            systemPrompt: SYSTEM_PROMPTS.GABRIEL,
            promptKey: 'GABRIEL',
            history: []
        },
        {
            id: 15,
            name: "Mephistopheles",
            systemPrompt: SYSTEM_PROMPTS.MEPHISTOPHELES,
            promptKey: 'MEPHISTOPHELES',
            history: []
        }
    ]

    // Define available group chats
    const groupChats = [
        {
            id: 'tech-team',
            name: 'Tech Team',
            promptKey: 'TECH_TEAM',
            members: [
                { promptKey: 'COWORKER', name: 'Coworker' },
                { promptKey: 'PROGRAMMING_TUTOR', name: 'Programming Tutor' },
                { promptKey: 'ENTREPRENEUR', name: 'Entrepreneur' }
            ],
            history: []
        },
        {
            id: 'therapy-group',
            name: 'Therapy Group',
            promptKey: 'THERAPY_GROUP',
            members: [
                { promptKey: 'THERAPIST', name: 'Therapist' },
                { promptKey: 'SPIRITUAL_TEACHER', name: 'Spiritual Teacher' }
            ],
            history: []
        },
        {
            id: 'council',
            name: 'The Council',
            promptKey: 'COUNCIL',
            members: [
                { promptKey: 'COWORKER', name: 'Coworker' },
                { promptKey: 'THERAPIST', name: 'Therapist' },
                { promptKey: 'ENTREPRENEUR', name: 'Entrepreneur' },
                { promptKey: 'SPIRITUAL_TEACHER', name: 'Spiritual Teacher' },
                { promptKey: 'GABRIEL', name: 'Gabriel' },
                { promptKey: 'MEPHISTOPHELES', name: 'Mephistopheles' }
            ],
            history: []
        }
    ]
    
    let activePersonaId = personas[0].id
    let activeGroupId = null
    let isGroupChat = false

    const personaListDiv = document.getElementById('persona-list')
    const chatHistoryDiv = document.getElementById('chat-history')
    const messageTextarea = document.getElementById('message-input')
    const sendButton = document.getElementById('send-button')

    // Storage management functions
    function saveChatsToLocalStorage() {
        try {
            const personasData = {}
            personas.forEach(persona => {
                personasData[persona.id] = persona.history
            })
            
            const groupsData = {}
            groupChats.forEach(group => {
                groupsData[group.id] = group.history
            })
            
            const storageData = {
                version: '1.0',
                personas: personasData,
                groups: groupsData
            }
            
            localStorage.setItem('chatData', JSON.stringify(storageData))
            console.log('Chat history saved to localStorage')
        } catch (error) {
            if (error instanceof DOMException && (error.name === 'QuotaExceededError' || error.code === 22)) {
                console.warn('Storage quota exceeded, trimming chat histories')
                trimChatHistories()
                saveChatsToLocalStorage() // Try again after trimming
            } else {
                console.error('Error saving to localStorage:', error)
            }
        }
    }
    
    function loadChatsFromLocalStorage() {
        try {
            const data = JSON.parse(localStorage.getItem('chatData'))
            
            if (!data || data.version !== '1.0') {
                console.info('No saved chats or version mismatch')
                return
            }
            
            // Restore individual persona chats
            if (data.personas) {
                personas.forEach(persona => {
                    if (data.personas[persona.id]) {
                        persona.history = data.personas[persona.id]
                    }
                })
            }
            
            // Restore group chats
            if (data.groups) {
                groupChats.forEach(group => {
                    if (data.groups[group.id]) {
                        group.history = data.groups[group.id]
                    }
                })
            }
            
            console.log('Chat history loaded from localStorage')
        } catch (error) {
            console.error('Error loading from localStorage:', error)
            // If data is corrupted, reset it
            localStorage.removeItem('chatData')
        }
    }
    
    function trimChatHistories() {
        // Keep only the last 50 messages for each chat
        const MAX_MESSAGES = 50
        
        personas.forEach(persona => {
            if (persona.history.length > MAX_MESSAGES) {
                persona.history = persona.history.slice(-MAX_MESSAGES)
            }
        })
        
        groupChats.forEach(group => {
            if (group.history.length > MAX_MESSAGES) {
                group.history = group.history.slice(-MAX_MESSAGES)
            }
        })
    }
    
    function clearCurrentChatHistory() {
        if (isGroupChat) {
            const group = groupChats.find(g => g.id === activeGroupId)
            if (group) {
                group.history = []
            }
        } else {
            const persona = personas.find(p => p.id === activePersonaId)
            if (persona) {
                persona.history = []
            }
        }
        
        saveChatsToLocalStorage()
        renderChatHistory()
    }
    
    function clearAllChatHistories() {
        if (confirm('Are you sure you want to clear all chat histories? This cannot be undone.')) {
            personas.forEach(persona => {
                persona.history = []
            })
            
            groupChats.forEach(group => {
                group.history = []
            })
            
            localStorage.removeItem('chatData')
            renderChatHistory()
        }
    }

    // Ensure button click works
    sendButton.addEventListener('click', (e) => {
        e.preventDefault()
        sendMessage()
    })

    // Render the list of personas.
    function renderPersonas() {
        console.log("Rendering personas:", personas)
        personaListDiv.innerHTML = ''
        
        // Add section for individual chats
        const individualSection = document.createElement('div')
        individualSection.className = 'chat-section'
        const individualHeader = document.createElement('h3')
        individualHeader.textContent = 'Individual Chats'
        individualSection.appendChild(individualHeader)
        
        personas.forEach(persona => {
            const div = document.createElement('div')
            div.className = !isGroupChat && persona.id === activePersonaId ? 'persona active' : 'persona'
            div.textContent = persona.name
            div.onclick = () => {
                changeActivePersona(persona.id)
                renderPersonas() // Re-render to update highlighting
            }
            individualSection.appendChild(div)
        })
        personaListDiv.appendChild(individualSection)
        
        // Add section for group chats
        const groupSection = document.createElement('div')
        groupSection.className = 'chat-section'
        const groupHeader = document.createElement('h3')
        groupHeader.textContent = 'Group Chats'
        groupSection.appendChild(groupHeader)
        
        groupChats.forEach(group => {
            const div = document.createElement('div')
            div.className = isGroupChat && group.id === activeGroupId ? 'persona group active' : 'persona group'
            div.textContent = group.name
            div.onclick = () => {
                changeActiveGroup(group.id)
                renderPersonas() // Re-render to update highlighting
            }
            groupSection.appendChild(div)
        })
        personaListDiv.appendChild(groupSection)
    }

    // Render the chat history for the active persona.
    function renderChatHistory() {
        chatHistoryDiv.innerHTML = ''
        let history = []
        
        if (isGroupChat) {
            const group = groupChats.find(g => g.id === activeGroupId)
            if (!group) return
            history = group.history
        } else {
            const persona = personas.find(p => p.id === activePersonaId)
            if (!persona) return
            history = persona.history
        }
        
        history.forEach((msg, index) => {
            const msgDiv = document.createElement('div')
            msgDiv.className = `message ${msg.sender}${msg.sender === 'user' ? ' end' : ' start'}`
            
            // Add typing class for typing indicators
            if (msg.isTyping) {
                msgDiv.className += ' typing'
            }
            
            // Add persona name for group chats
            if (isGroupChat && msg.sender !== 'user') {
                const nameSpan = document.createElement('div')
                nameSpan.className = 'message-sender'
                nameSpan.textContent = msg.personaName
                msgDiv.appendChild(nameSpan)
            }
            
            const textDiv = document.createElement('div')
            textDiv.className = 'message-content'
            
            if (msg.isTyping) {
                textDiv.innerHTML = '<div class="typing-indicator"><span class="dot">.</span><span class="dot">.</span><span class="dot">.</span></div>'
                textDiv.style.opacity = '0.8'
            } else {
                textDiv.innerHTML = msg.text.replace(/\n/g, '<br>')
            }
            
            msgDiv.appendChild(textDiv)
            chatHistoryDiv.appendChild(msgDiv)
        })
        chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight
    }

    // Add a new message to the conversation.
    function addMessage(text, sender, personaName = null, isTyping = false) {
        try {
            if (isGroupChat) {
                const group = groupChats.find(g => g.id === activeGroupId)
                if (!group) return
                group.history.push({text, sender, personaName, isTyping})
            } else {
                const persona = personas.find(p => p.id === activePersonaId)
                if (!persona) return
                persona.history.push({text, sender, personaName, isTyping})
            }
            
            // Save to localStorage after adding a message (except for typing indicators)
            if (!isTyping) {
                saveChatsToLocalStorage()
            }
            
            // Force a repaint
            window.requestAnimationFrame(() => {
                renderChatHistory()
            })
        } catch (error) {
            console.error("Error in addMessage:", error)
        }
    }

    function autoResizeTextarea() {
        messageTextarea.style.height = 'auto'
        messageTextarea.style.height = Math.min((messageTextarea.scrollHeight - 22), 330) + 'px'
    }

    messageTextarea.addEventListener('input', autoResizeTextarea)
    messageTextarea.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault()
            sendMessage()
        }
    })

    async function sendMessage() {
        const apiUrl = window.location.hostname === 'localhost' 
            ? 'http://localhost:8080/chat'
            : 'https://chat.jonnyspicer.com/chat'

        try {
            const text = messageTextarea.value.trim()
            if (!text) return
            
            if (isGroupChat) {
                const group = groupChats.find(g => g.id === activeGroupId)
                if (!group) return
                
                addMessage(text, 'user')
                messageTextarea.value = ''
                messageTextarea.style.height = 'auto'
                sendButton.disabled = true
                
                // Add a single typing indicator
                addMessage('', 'bot', null, true)

                // Format messages for the API
                const messages = group.history
                    .filter(msg => !msg.isTyping) // Remove temporary typing indicators
                    .map(msg => ({
                        role: msg.sender === 'user' ? 'user' : 'assistant',
                        content: msg.text
                    }))
                
                try {
                    // Use fetch with POST for group chats
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Accept': 'text/event-stream'
                        },
                        body: JSON.stringify({
                            promptKey: group.promptKey,
                            messages: messages
                        })
                    })
                    
                    if (!response.ok) {
                        throw new Error(`Server returned ${response.status}: ${response.statusText}`)
                    }
                    
                    // Remove typing indicator
                    group.history = group.history.filter(msg => !msg.isTyping)
                    
                    // Track which members are still typing
                    const typingMembers = new Set(group.members.map(m => m.promptKey))
                    
                    // Add a single typing indicator for the group
                    addMessage('', 'bot', null, true)
                    renderChatHistory()
                    
                    // Process the streaming response
                    const reader = response.body.getReader()
                    const decoder = new TextDecoder()
                    
                    let buffer = ''
                    
                    try {
                        while (true) {
                            const { done, value } = await reader.read()
                            if (done) break
                            
                            // Decode and buffer the chunk
                            buffer += decoder.decode(value, { stream: true })
                            
                            // Process complete SSE messages
                            const lines = buffer.split('\n\n')
                            buffer = lines.pop() || '' // Keep the last potentially incomplete event
                            
                            for (const line of lines) {
                                if (line.trim() && line.startsWith('data: ')) {
                                    try {
                                        const data = JSON.parse(line.substring(6))
                                        console.log("SSE message:", data)
                                        
                                        if (data.member && data.response) {
                                            // Find the member
                                            const member = group.members.find(m => m.promptKey === data.member)
                                            if (member) {
                                                // Remove from typing set
                                                typingMembers.delete(data.member)
                                                
                                                // Remove any existing typing indicator so we can add it back at the end
                                                const typingIndicators = group.history.filter(msg => msg.isTyping)
                                                group.history = group.history.filter(msg => !msg.isTyping)
                                                
                                                // Remove any existing message from this member
                                                group.history = group.history.filter(msg => 
                                                    !(msg.sender === 'bot' && msg.personaName === member.name)
                                                )
                                                
                                                // Add the new response
                                                group.history.push({
                                                    text: data.response.trim(),
                                                    sender: 'bot',
                                                    personaName: member.name
                                                })
                                                
                                                // Save each member's response as it comes in
                                                saveChatsToLocalStorage()
                                                
                                                // Add typing indicator back if we're not complete
                                                if (typingMembers.size > 0) {
                                                    group.history.push({
                                                        text: '',
                                                        sender: 'bot',
                                                        isTyping: true
                                                    })
                                                }
                                                
                                                renderChatHistory()
                                            }
                                        }
                                        
                                        if (data.status === 'complete') {
                                            console.log("SSE connection complete")
                                            // Clear any remaining typing indicators
                                            group.history = group.history.filter(msg => !msg.isTyping)
                                            renderChatHistory()
                                            break
                                        }
                                    } catch (error) {
                                        console.error("Error parsing SSE message:", error)
                                    }
                                }
                            }
                        }
                    } catch (error) {
                        console.error("Error processing stream:", error)
                        
                        // If we have no responses yet, show errors
                        if (!group.history.some(msg => msg.sender === 'bot' && !msg.isTyping)) {
                            // Clear typing indicators
                            group.history = group.history.filter(msg => !msg.isTyping)
                            
                            group.members.forEach(member => {
                                group.history.push({
                                    text: "Error: Failed to process stream",
                                    sender: 'bot',
                                    personaName: member.name
                                })
                            })
                            renderChatHistory()
                        }
                    }
                } catch (error) {
                    console.error("Error in group chat:", error)
                    // Remove all temporary "..." messages
                    group.history = group.history.filter(msg => msg.text !== '...')
                    
                    // Add error message for each member that failed
                    group.members.forEach(member => {
                        group.history.push({
                            text: "Error: Failed to get response",
                            sender: 'bot',
                            personaName: member.name
                        })
                    })
                    renderChatHistory()
                }
                sendButton.disabled = false
            } else {
                // Store the target persona ID when sending
                const targetPersonaId = activePersonaId
                
                // Force a synchronous pause to ensure UI updates
                await new Promise(resolve => setTimeout(resolve, 0))
                
                addMessage(text, 'user')
                messageTextarea.value = ''
                messageTextarea.style.height = 'auto' // Reset height
                sendButton.disabled = true
                
                // Force another synchronous pause
                await new Promise(resolve => setTimeout(resolve, 0))
                
                // Get the target persona
                const targetPersona = personas.find(p => p.id === targetPersonaId)
                
                // Add a typing indicator
                addMessage('', 'bot', null, true)

                // Format messages for Claude's API
                const messages = targetPersona.history
                    .filter(msg => !msg.isTyping) // Remove typing indicators
                    .map(msg => ({
                        role: msg.sender === 'user' ? 'user' : 'assistant',
                        content: msg.text
                    }))
                console.log("Formatted messages:", messages)

                
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        promptKey: targetPersona.promptKey,
                        messages: messages
                    })
                })
                if (!response.ok) {
                    throw new Error('Something went wrong')
                }
                const data = await response.json()
                console.log("Response:", data)
                
                // Remove the typing indicator
                targetPersona.history = targetPersona.history.filter(msg => !msg.isTyping)
                
                // Add the response to the target persona's history
                targetPersona.history.push({
                    text: data.completion.trim(),
                    sender: 'bot',
                    personaName: targetPersona.name
                })
                // Save to localStorage after receiving individual response
                saveChatsToLocalStorage()
                
                // Only re-render if we're still viewing the target persona
                if (activePersonaId === targetPersonaId) {
                    renderChatHistory()
                }
            }
        } catch (error) {
            console.error("Uncaught error in sendMessage:", error)
        } finally {
            sendButton.disabled = false
        }
    }

    // Add info button functionality
    const infoButton = document.getElementById('info-button')
    const infoPopup = document.getElementById('info-popup')
    let isPopupOpen = false

    // Add settings button functionality
    const settingsButton = document.getElementById('settings-button')
    const settingsPopup = document.getElementById('settings-popup')
    const clearChatBtn = document.getElementById('clear-chat-button')
    const clearAllBtn = document.getElementById('clear-all-button')
    let isSettingsOpen = false

    // Add members button functionality
    const membersButton = document.getElementById('members-button')
    const membersPopup = document.getElementById('members-popup')
    const memberList = document.getElementById('member-list')
    let isMembersOpen = false

    function toggleMembersPopup() {
        isMembersOpen = !isMembersOpen
        membersPopup.classList.toggle('hidden')
        membersButton.classList.toggle('active')
    }

    function closeMembersPopup(event) {
        if (isMembersOpen && !membersPopup.contains(event.target) && !membersButton.contains(event.target)) {
            isMembersOpen = false
            membersPopup.classList.add('hidden')
            membersButton.classList.remove('active')
        }
    }

    membersButton.addEventListener('click', (e) => {
        e.stopPropagation()
        toggleMembersPopup()
    })

    document.addEventListener('click', closeMembersPopup)

    function updateMembersButton() {
        if (isGroupChat) {
            const group = groupChats.find(g => g.id === activeGroupId)
            if (group) {
                // Show the members button and update count
                membersButton.classList.remove('hidden')
                
                // Update the members list in the popup
                memberList.innerHTML = ''
                group.members.forEach(member => {
                    const li = document.createElement('li')
                    li.textContent = member.name
                    memberList.appendChild(li)
                })
            }
        } else {
            // Hide the members button for individual chats
            membersButton.classList.add('hidden')
        }
    }

    function toggleSettingsPopup() {
        isSettingsOpen = !isSettingsOpen
        settingsPopup.classList.toggle('hidden')
        settingsButton.classList.toggle('active')
    }

    function closeSettingsPopup(event) {
        if (isSettingsOpen && !settingsPopup.contains(event.target) && !settingsButton.contains(event.target)) {
            isSettingsOpen = false
            settingsPopup.classList.add('hidden')
            settingsButton.classList.remove('active')
        }
    }

    settingsButton.addEventListener('click', (e) => {
        e.stopPropagation()
        toggleSettingsPopup()
    })

    clearChatBtn.addEventListener('click', (e) => {
        clearCurrentChatHistory()
        toggleSettingsPopup()
    })

    clearAllBtn.addEventListener('click', (e) => {
        clearAllChatHistories()
        toggleSettingsPopup()
    })

    document.addEventListener('click', closeSettingsPopup)

    function toggleInfoPopup() {
        isPopupOpen = !isPopupOpen
        infoPopup.classList.toggle('hidden')
        infoButton.classList.toggle('active')
    }

    function closeInfoPopup(event) {
        if (isPopupOpen && !infoPopup.contains(event.target) && !infoButton.contains(event.target)) {
            isPopupOpen = false
            infoPopup.classList.add('hidden')
            infoButton.classList.remove('active')
        }
    }

    infoButton.addEventListener('click', (e) => {
        e.stopPropagation()
        toggleInfoPopup()
    })

    document.addEventListener('click', closeInfoPopup)

    function changeActivePersona(personaId) {
        activePersonaId = personaId
        activeGroupId = null
        isGroupChat = false
        updateChatTitle()
        updateMembersButton()
        renderChatHistory()
    }

    function changeActiveGroup(groupId) {
        activeGroupId = groupId
        activePersonaId = null
        isGroupChat = true
        updateChatTitle()
        updateMembersButton()
        renderChatHistory()
    }

    function updateChatTitle() {
        const chatTitleElement = document.getElementById('chat-title')
        
        if (isGroupChat) {
            const group = groupChats.find(g => g.id === activeGroupId)
            if (group) {
                chatTitleElement.textContent = group.name
            }
        } else {
            const persona = personas.find(p => p.id === activePersonaId)
            if (persona) {
                chatTitleElement.textContent = persona.name
            }
        }
    }

    // Initial setup
    document.addEventListener('DOMContentLoaded', () => {
        // Load saved chats from localStorage
        loadChatsFromLocalStorage()
        
        // Initial render
        renderPersonas()
        renderChatHistory()
        updateChatTitle()
        updateMembersButton()
    })
</script>
{{ end }} 